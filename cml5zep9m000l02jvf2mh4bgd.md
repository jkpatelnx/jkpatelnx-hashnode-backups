---
title: "Linux Processes and Services: Hands-On Troubleshooting Practice for DevOps"
seoTitle: "Mastering systemctl: Linux Processes & Services"
seoDescription: "Learn Linux fundamentals hands-on: use systemctl to monitor processes, inspect services, and troubleshoot with logs for real-world skills"
datePublished: Tue Feb 03 2026 02:30:42 GMT+0000 (Coordinated Universal Time)
cuid: cml5zep9m000l02jvf2mh4bgd
slug: linux-processes-and-services-hands-on-troubleshooting-practice-for-devops
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1770077820838/37b11ed8-9c37-497e-ba9e-3bfaeb18be08.png
tags: ssh, systemd, linux-commands, linux-systemd, linux-trableshooting, linux-services, linux-processes

---

The goal is to build a practical understanding of how processes, services, and logs behave on a real Linux system. These are core Linux fundamentals that are used daily by system administrators, DevOps engineers, and cloud practitioners when monitoring systems and troubleshooting issues.

Instead of focusing on theory alone, this practice emphasizes running real commands and observing actual output.

## 1\. Checking Running Processes

A process in Linux represents a running instance of a program. Every command, service, or application running on the system operates as a process. Monitoring processes helps identify performance issues, resource usage, and unexpected behavior.

In this practice:

* Checked active processes on the system
    
* Observed real-time resource usage
    
* Identified how Linux manages multiple processes simultaneously
    

To do this, run at least two process-related commands, such as:

* `ps` to list running processes
    
* `top` to monitor processes in real time
    
* `pgrep` to search for specific processes These commands are commonly used during performance analysis and incident investigation.
    

Displays the top 5 running processes sorted by highest CPU and memory usage, showing details like user, PID, memory usage, and the command being executed.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770080343582/571003b6-646a-4bb1-9cb7-ee05ec723763.png align="center")

Displays a real-time view of running processes, showing CPU usage, memory usage, and system load.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770080462433/922f74ae-7226-42f8-8f54-ef8224676b1b.png align="center")

Finds and displays the process IDs (PIDs) of all running SSH.  
Lists all running processes and filters the output to show only lines related to the SSH daemon.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770080659640/da6642d9-571a-4f42-a684-78878648b7d2.png align="center")

## 2\. Inspecting a systemd Service

Most modern Linux distributions use systemd as the system and service manager. Services are background processes that start automatically and provide essential functionality, such as remote access, scheduling, and container management.

For this practice:

* Selected one systemd service available on my system (for example: ssh)
    
* Inspected its current status
    
* Reviewed how Linux tracks and manages running services Use at least two service-related commands, including:
    
* `systemctl status <servicen-name>` to check service health
    
* `systemctl list-units` to view active services Understanding these commands is critical when diagnosing service failures or confirming whether a service is operational after configuration changes.
    

Displays the current status of the SSH service, including whether it is running, its main process ID, and recent log entries.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770080870171/ddc76066-7292-4a28-b442-740dd155fe0b.png align="center")

Lists all active systemd units (services, sockets, timers, and more) that are currently loaded and running on the system.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770080939850/8cfa7df4-3e0b-4f57-8700-0c53d73aac25.png align="center")

## 3\. Viewing Logs and Basic Troubleshooting

Logs play a crucial role in Linux troubleshooting. When a service fails or behaves unexpectedly, logs often provide the first clues about what went wrong. Learning how to access and interpret logs is an essential Linux skill.

As part of this practice:

* Examined logs related to the selected service
    
* Reviewed recent system activity
    
* Follow a small troubleshooting flow to validate service behavior I used at least two log-related commands, such as:
    
* `journalctl -u <service-name>` to view service logs
    
* `tail -n 50 <log-file-name>` to inspect recent log entries
    

Displays log entries generated by the SSH service, helping troubleshoot login and service-related issues.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770081096209/2a4fc1ef-592c-4065-bfd0-a9e9bf92a084.png align="center")

Shows the last 50 authentication log entries and filters them to display only SSH-related login activity.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1770081236503/6196d9f8-9883-48b8-8b84-acfda0f8d738.png align="center")

## 4\. Capturing a Simple Linux Troubleshooting Flow

To connect processes, services, and logs together, follow a small troubleshooting workflow. This simulates how issues are investigated in real-world Linux environments.

The troubleshooting flow included:

* Verifying the service status
    
* Restarting the service when necessary
    
* Rechecking logs to confirm normal operation This simple flow shows how multiple Linux commands work together to diagnose and resolve issues efficiently.